<!DOCTYPE html>
<html lang="en"
data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>PH TUBE</title>
    <!-- CSS link -->
    <link rel="stylesheet" href="./blog.css">
    <!-- DaisyUI link -->
    <link href="https://cdn.jsdelivr.net/npm/daisyui@3.6.4/dist/full.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <title>PH Tube BLOG</title>
</head>
<body>
    <header class="mx-[50px]">
        <section>
            <nav class="flex flex-row justify-between mt-[52px]  border-b-2 pb-[36px]">  
                <div id="logo">
                    <img src="./Logo.png" alt="">
                </div>
                <div id="blog">
                    <button class="btn btn-primary bg-[#FF1F3D] border-none" onclick="history.back()">Back</button>
                </div>
            </nav>
        </section>
    </header>
    <main class="mx-[60px]">
        <article>
            <h1 class="text-[30px] lg:text-[50px]  text-red-500 font-semibold ">Variable Scope in JavaScript</h1>
            <p class="text-[24px] font-bold">JavaScript has three variable declaration keywords with different scopes:</p>
            <h3 class="pt-[20px] font-bold">1. Var</h3>
            <ul class= "mx-[40px]">
                <li>i. Function-scoped.</li>
                <li>ii. Hoisted to the top of their containing function or global scope.</li>
                <li>iii. Allows re-declaration in the same scope.</li>
                <li>iv. Can lead to unexpected behavior in block-level scope.</li>
            </ul>
            <div class="bg-black text-gray-100 rounded-lg mt-[20px] w-[70%]">
                <h3 class="bg-gray-500 text-white rounded-t-lg p-2">Javascript</h3>
                <p class="p-5">
                    <pre>
    function example() {
        var x = 10;
        if (true) {
            var x = 20; // Re-declaration in the same scope
        }
          console.log(x); // Outputs 20
        }
                    </pre>
                  </p>
            </div>
            <h3 class="pt-[20px] font-bold">2. let</h3>
            <ul class= "mx-[40px]">
                <li>i. Block-scoped, limited to the block in which they are defined.</li>
                <li>ii. Hoisted but not initialized before declaration.</li>
                <li>iii. Cannot be re-declared in the same scope.</li>
            </ul>
            <div class="bg-black text-gray-100 rounded-lg mt-[20px] w-[70%]">
                <h3 class="bg-gray-500 text-white rounded-t-lg p-2">Javascript</h3>
                <p class="p-5">
                    <pre>
    function example() {
        let y = 10;
        if (true) {
            let y = 20; // Different variable in a different scope
        }
            console.log(y); // Outputs 10
        }                        
                    </pre>
                  </p>
            </div>
            <h3 class="pt-[20px] font-bold">3. Const</h3>
            <ul class= "mx-[40px]">
                <li>i. Block-scoped, like let.</li>
                <li>ii. Hoisted but not initialized before declaration.</li>
                <li>iii. Immutable; cannot be reassigned after declaration, but object properties can be modified.</li>
               
            </ul>
            <div class="bg-black text-gray-100 rounded-lg mt-[20px] w-[70%]">
                <h3 class="bg-gray-500 text-white rounded-t-lg p-2">Javascript</h3>
                <p class="p-5">
                    <pre>
    const pi = 3.14159;
    pi = 3; // Error: Cannot reassign a const variable
                       
    const person = { name: 'John' };
    person.name = 'Jane'; // Allowed, modifies the object's property                        
                    </pre>
                  </p>
            </div>
        </article>
        <article class="mb-[70px]">
            <h1 class="text-[30px] lg:text-[50px] text-red-500 font-semibold mt-[70px] ">
                Use Cases of null and undefined in JavaScript</h1>
            <p class="text-[24px] font-bold">In JavaScript, null and undefined are both used to represent the absence of a value, but they are subtly different and have distinct use cases.</p>
            <h3 class="pt-[20px] font-bold">1. null:</h3>
            <ul class= "mx-[40px]">
                <li>Explicit Assignment: You can assign null to a variable or property to explicitly indicate that it has no value or that it should be empty.
                    <div class="bg-black text-gray-100 rounded-lg mt-[20px] mb-[20px] w-[70%]">
                        <h3 class="bg-gray-500 text-white rounded-t-lg p-2">Javascript</h3>
                        <p class="p-3">
                            <pre>
    let user = null; // Explicitly indicating the absence of a user
                            </pre>
                          </p>
                    </div>
                </li>
                <li>As a Reset Value: It can be used to reset a variable or object property.
                    <div class="bg-black text-gray-100 rounded-lg mt-[20px] mb-[20px] w-[70%]">
                        <h3 class="bg-gray-500 text-white rounded-t-lg p-2">Javascript</h3>
                        <p class="p-3">
                            <pre>
    let data = fetchData();
    if (data.error) {
        data = null; // Resetting the data object
    }                              
                            </pre>
                          </p>
                    </div>
                </li>
            </ul>
           
            <h3 class="pt-[20px] font-bold">2. undefined:</h3>
            <ul class= "mx-[40px]">
                <li>Implicit Absence: Variables or properties that have not been assigned any value are automatically set to undefined.
                    <div class="bg-black text-gray-100 rounded-lg mt-[20px] mb-[20px] w-[70%]">
                        <h3 class="bg-gray-500 text-white rounded-t-lg p-2">Javascript</h3>
                        <p class="p-3">
                            <pre>
    let name; // name is undefined until assigned a value
                            </pre>
                          </p>
                    </div>
                </li>Function Return: Functions that do not explicitly return a value will return undefined by default.
                    <div class="bg-black text-gray-100 rounded-lg mt-[20px] mb-[20px] w-[70%]">
                        <h3 class="bg-gray-500 text-white rounded-t-lg p-2">Javascript</h3>
                        <p class="p-3">
                            <pre>
    function example() {
     // No return statement, so it returns undefined
    }
                            </pre>
                          </p>
                    </div>
                </li>
            </ul>
            <h2 class="text-[20px] font-bold mt-[20px]">Use Cases Summary:</h2>
            <ul class="mx-[40px] w-[70%]">
                <li>1. Use null when you want to explicitly indicate the absence of a value or need to reset a variable or property to an empty state.</li>
                <li>2. Use undefined when a variable or property has not been assigned a value, or as the implicit return value for functions without a return statement.</li>
                <li>3. Be cautious when comparing them, as null and undefined are not equal, but loosely equal (null == undefined). Consider using strict equality (null === undefined) when needed.</li>
                <li>4. Choose the appropriate one based on the context and whether you need to explicitly represent the absence of a value or rely on the default behavior of undefined.</li>
            </ul>
        </article>
        <article class="mb-[70px]">
            <h1 class="text-[30px] lg:text-[50px] text-red-500 font-semibold mt-[70px] ">
                REST API (Representational State Transfer API)</h1>
            <p class="text-[20px] font-semibold ">A REST API is a set of rules and conventions for building and interacting with web services. It is based on the principles of REST, a software architectural style designed to provide a standardized way for systems to communicate over HTTP.</p>
            <p class="text-[24px] font-bold pt-[15px] pb-[10px]">Key characteristics of a REST API include:</p>
           <ul class="mx-[40px]">
            <li><span class="text-[20px] font-semibold">Statelessness: </span>Each request from a client to a server must contain all the information needed to understand and process the request. The server should not store any client state between requests. This makes the API highly scalable and easy to cache.</li>
            <li><span class="text-[20px] font-semibold">Resource-Based: </span>REST APIs are built around resources, which are identified by URIs (Uniform Resource Identifiers). Resources can represent data objects, such as users or products, and are manipulated using standard HTTP methods like GET (retrieve), POST (create), PUT (update), and DELETE (remove).</li>
            <li><span class="text-[20px] font-semibold">HTTP Methods: </span>REST APIs use standard HTTP methods to perform actions on resources. For example, GET retrieves data, POST creates new resources, PUT updates existing resources, and DELETE removes resources. The uniformity of HTTP methods simplifies API design and usage.</li>
            <li><span class="text-[20px] font-semibold">Representation: </span>Resources can have multiple representations, such as JSON, XML, or HTML. Clients request the representation they need, and servers respond with the appropriate data format. This flexibility allows clients to choose the most suitable representation.</li>
            <li><span class="text-[20px] font-semibold">Stateless Communication: </span>Communication between client and server is stateless, meaning each request is independent. This simplifies error handling and supports scalability and load balancing.</li>
            <li><span class="text-[20px] font-semibold">Layered System: </span>REST APIs can be implemented as a layered system with multiple components. Each component has a specific role, and clients interact with the top layer without needing to know the inner workings of lower layers.</li>
            <li><span class="text-[20px] font-semibold">Client-Server Architecture: </span>REST separates the client (user interface) from the server (data storage and processing). This separation allows for flexibility, as clients and servers can evolve independently.
            </li>
           </ul>
        </article>
    </main>
</body>
</html>

